<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Festa do Ch√° da Alice 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Georgia', serif;
            background-color: #87CEEB; /* C√©u azul */
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #2c0e37;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #d4af37;
            pointer-events: none;
            user-select: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0;
            font-size: 24px;
            color: #6a0dad;
        }
        p {
            margin: 5px 0 0;
            font-size: 16px;
        }
        #score-display {
            font-size: 32px;
            font-weight: bold;
            color: #d9004c;
            margin-top: 10px;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            font-size: 18px;
            pointer-events: none;
        }
        .eat-text {
            position: absolute;
            font-weight: bold;
            color: #ff0055;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>Festa do Ch√° üé©</h1>
        <p>Bolos comidos:</p>
        <div id="score-display">0</div>
    </div>

    <div id="instructions">
        Mova o RATO (ou toque e arraste) para levar o bolo at√© √† boca da Alice!
    </div>

    <script>
        // --- Vari√°veis Globais ---
        let scene, camera, renderer;
        let aliceGroup, headGroup, mouth, rightArm, leftArm;
        let currentCake;
        let raycaster, mouse;
        let dragPlane; // Plano invis√≠vel para arrastar o bolo
        let score = 0;
        let particles = [];
        let isEating = false;
        let jumpTime = 0; // Vari√°vel para controlar o pulo
        let clock = new THREE.Clock();
        
        // Cores
        const colors = {
            skin: 0xffdbac,
            dress: 0x348feb, // Azul Alice
            apron: 0xffffff,
            hair: 0xffd700, // Loiro Dourado
            cake: [0xff99cc, 0x663300, 0xffeb3b], // Rosa, Choco, Amarelo
            grass: 0x4caf50
        };

        init();
        animate();

        function init() {
            // 1. Configura√ß√£o da Cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

            // 2. C√¢mara
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 12);
            camera.lookAt(0, 2, 0);

            // 3. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. Luzes
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // 5. Input
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Plano invis√≠vel para o rato interagir
            const planeGeo = new THREE.PlaneGeometry(30, 20);
            const planeMat = new THREE.MeshBasicMaterial({ visible: false });
            dragPlane = new THREE.Mesh(planeGeo, planeMat);
            dragPlane.position.z = 1; // Aproximei de 2 para 1 para facilitar
            scene.add(dragPlane);

            // 6. Construir o Mundo
            createEnvironment();
            createTable();
            aliceGroup = createAlice();
            aliceGroup.position.set(0, 0, -2);
            scene.add(aliceGroup);

            spawnCake();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('touchmove', onTouchMove, { passive: false });
        }

        // --- Cria√ß√£o de Objetos ---

        function createEnvironment() {
            // Ch√£o
            const geometry = new THREE.PlaneGeometry(200, 200);
            const material = new THREE.MeshStandardMaterial({ 
                color: colors.grass,
                roughness: 0.8 
            });
            const floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Cogumelos gigantes (decorativos)
            for (let i = 0; i < 6; i++) {
                const mushGroup = new THREE.Group();
                
                // Caule
                const stemGeo = new THREE.CylinderGeometry(0.5, 0.8, 3, 8);
                const stemMat = new THREE.MeshLambertMaterial({ color: 0xf5f5dc });
                const stem = new THREE.Mesh(stemGeo, stemMat);
                stem.position.y = 1.5;
                
                // Chap√©u
                const capGeo = new THREE.ConeGeometry(2.5, 2, 8);
                const capMat = new THREE.MeshLambertMaterial({ color: i % 2 === 0 ? 0xff0055 : 0x6600cc });
                const cap = new THREE.Mesh(capGeo, capMat);
                cap.position.y = 3;
                
                mushGroup.add(stem);
                mushGroup.add(cap);
                
                // Posi√ß√£o aleat√≥ria no fundo
                const x = (Math.random() - 0.5) * 40;
                const z = -10 - Math.random() * 20;
                mushGroup.position.set(x, 0, z);
                mushGroup.castShadow = true;
                scene.add(mushGroup);
            }
        }

        function createTable() {
            // Mesa longa
            const tableGeo = new THREE.BoxGeometry(14, 0.5, 6);
            const tableMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Toalha branca
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.set(0, 2, 0);
            table.receiveShadow = true;
            scene.add(table);

            // Pernas da mesa
            const legGeo = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 }); // Madeira
            const positions = [
                [-6, 1, 2.5], [6, 1, 2.5],
                [-6, 1, -2.5], [6, 1, -2.5]
            ];
            
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, legMat);
                leg.position.set(...pos);
                scene.add(leg);
            });

            // Bules e x√≠caras
            const teapotGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const teaMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, metalness: 0.3 });
            const pot = new THREE.Mesh(teapotGeo, teaMat);
            pot.position.set(4, 2.8, 1);
            scene.add(pot);

            const cupGeo = new THREE.CylinderGeometry(0.2, 0.15, 0.3);
            const cup1 = new THREE.Mesh(cupGeo, teaMat);
            cup1.position.set(-3, 2.4, 1);
            scene.add(cup1);
        }

        function createAlice() {
            const group = new THREE.Group();

            // 1. Corpo (Vestido)
            const bodyGeo = new THREE.ConeGeometry(1.5, 4, 16);
            const bodyMat = new THREE.MeshStandardMaterial({ color: colors.dress });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 2;
            body.castShadow = true;
            group.add(body);

            // Avental
            const apronGeo = new THREE.BoxGeometry(1.6, 2, 0.2);
            const apronMat = new THREE.MeshStandardMaterial({ color: colors.apron });
            const apron = new THREE.Mesh(apronGeo, apronMat);
            apron.position.set(0, 1.5, 1.4); // Na frente do vestido
            apron.rotation.x = -0.1;
            group.add(apron);

            // 2. Cabe√ßa
            headGroup = new THREE.Group();
            headGroup.position.y = 4;

            const headGeo = new THREE.SphereGeometry(1, 32, 32);
            const skinMat = new THREE.MeshStandardMaterial({ color: colors.skin });
            const head = new THREE.Mesh(headGeo, skinMat);
            headGroup.add(head);

            // Cabelo
            const hairGeo = new THREE.SphereGeometry(1.1, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2.5);
            const hairMat = new THREE.MeshStandardMaterial({ color: colors.hair });
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.y = 0.1;
            hair.rotation.x = -0.2;
            headGroup.add(hair);

            // Olhos
            const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.3, 0.1, 0.9);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.3, 0.1, 0.9);
            headGroup.add(leftEye);
            headGroup.add(rightEye);

            // Boca (O alvo!)
            const mouthGeo = new THREE.SphereGeometry(0.2, 16, 16, 0, Math.PI * 2, 0, Math.PI/2);
            const mouthMat = new THREE.MeshBasicMaterial({ color: 0x5c0000 });
            mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, -0.3, 0.92);
            mouth.rotation.x = 0.2;
            // Guardar refer√™ncia global para verificar colis√£o
            mouth.userData = { isMouth: true };
            headGroup.add(mouth);

            group.add(headGroup);

            // Bra√ßos (simples)
            const armGeo = new THREE.CylinderGeometry(0.2, 0.2, 2);
            leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(-1.2, 3, 0.5);
            leftArm.rotation.z = 0.5;
            leftArm.rotation.x = -0.5;
            group.add(leftArm);

            rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(1.2, 3, 0.5);
            rightArm.rotation.z = -0.5;
            rightArm.rotation.x = -0.5;
            group.add(rightArm);

            return group;
        }

        function spawnCake() {
            if (currentCake) {
                scene.remove(currentCake);
            }

            const type = Math.floor(Math.random() * colors.cake.length);
            const cakeColor = colors.cake[type];

            const cakeGroup = new THREE.Group();

            // Base do bolo
            const cakeGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 16);
            const cakeMat = new THREE.MeshStandardMaterial({ color: cakeColor });
            const base = new THREE.Mesh(cakeGeo, cakeMat);
            cakeGroup.add(base);

            // Cereja ou decora√ß√£o
            const cherryGeo = new THREE.SphereGeometry(0.15);
            const cherryMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const cherry = new THREE.Mesh(cherryGeo, cherryMat);
            cherry.position.y = 0.3;
            cakeGroup.add(cherry);

            // Tag "Eat Me" (simples plano branco)
            const tagGeo = new THREE.PlaneGeometry(0.4, 0.2);
            const tagMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const tag = new THREE.Mesh(tagGeo, tagMat);
            tag.position.set(0, 0.1, 0.4);
            cakeGroup.add(tag);

            // Spawn na frente da c√¢mara
            cakeGroup.position.set(0, 3, 5); 
            scene.add(cakeGroup);
            currentCake = cakeGroup;
            isEating = false;
        }

        // --- L√≥gica do Jogo ---

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            updateCakePosition();
        }

        function onTouchMove(event) {
            event.preventDefault();
            mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            updateCakePosition();
        }

        function updateCakePosition() {
            if (!currentCake || isEating) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(dragPlane);

            if (intersects.length > 0) {
                // Move o bolo suavemente
                const target = intersects[0].point;
                
                // L√≥gica de profundidade din√¢mica: Se estiver alto (perto da cara), vai um pouco para o fundo
                // Isso ajuda a criar a ilus√£o de entregar na boca
                let targetZ = target.z;
                if (target.y > 2) { 
                    targetZ = -0.5; // Empurra para o fundo quando est√° alto
                }

                currentCake.position.x = THREE.MathUtils.lerp(currentCake.position.x, target.x, 0.2);
                currentCake.position.y = THREE.MathUtils.lerp(currentCake.position.y, target.y, 0.2);
                currentCake.position.z = THREE.MathUtils.lerp(currentCake.position.z, targetZ, 0.1);
            }
        }

        function checkCollision() {
            if (!currentCake || isEating || !mouth) return;

            // Posi√ß√£o do mundo da boca da Alice
            const mouthWorldPos = new THREE.Vector3();
            mouth.getWorldPosition(mouthWorldPos);

            const distance = currentCake.position.distanceTo(mouthWorldPos);

            // Fazer a Alice olhar para o bolo
            if (headGroup) {
                const lookTarget = currentCake.position.clone();
                lookTarget.y -= 4; 
                headGroup.lookAt(lookTarget);
            }

            // Dist√¢ncia para comer (Aumentada para 2.5 para facilitar)
            if (distance < 2.5) {
                eatCake();
            }
        }

        function eatCake() {
            isEating = true;
            score++;
            document.getElementById('score-display').innerText = score;

            showFloatingText(window.innerWidth/2, window.innerHeight/2, "NHAM!");

            mouth.scale.set(1.5, 1.5, 1.5);
            
            // Part√≠culas
            createCrumbs(currentCake.position, colors.cake[score % colors.cake.length]);

            // Iniciar pulo
            jumpTime = 1.0; 
            
            scene.remove(currentCake);
            
            setTimeout(() => {
                if(mouth) mouth.scale.set(1, 1, 1);
                spawnCake();
            }, 800);
        }

        function createCrumbs(pos, color) {
            const particleCount = 10;
            const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const material = new THREE.MeshBasicMaterial({ color: color });

            for (let i = 0; i < particleCount; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(pos);
                
                // Velocidade aleat√≥ria
                mesh.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2 + 0.1, // Sobe um pouco
                    (Math.random() - 0.5) * 0.2
                );
                
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        function showFloatingText(x, y, text) {
            const el = document.createElement('div');
            el.className = 'eat-text';
            el.innerText = text;
            el.style.left = (x - 20) + 'px';
            el.style.top = (y - 50) + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.01; // Gravidade
                p.rotation.x += 0.1;

                if (p.position.y < 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Anima√ß√£o leve da Alice (respirar + Pulo)
            if(aliceGroup) {
                let yOffset = Math.sin(time * 2) * 0.05; // Respira√ß√£o base
                
                // Adiciona o pulo se estiver ativo
                if (jumpTime > 0) {
                    yOffset += Math.sin(jumpTime * Math.PI) * 0.5;
                    jumpTime -= 0.05; // Velocidade do pulo
                    if (jumpTime < 0) jumpTime = 0;
                }
                
                aliceGroup.position.y = yOffset;
            }

            // Anima√ß√£o do bolo flutuando
            if (currentCake && !isEating) {
                currentCake.rotation.y += 0.01;
                currentCake.rotation.z = Math.sin(time * 3) * 0.1;
            }

            checkCollision();
            updateParticles();

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>