<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alice: A Corrida para o Castelo</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #87CEEB; /* C√©u azul */
            font-family: 'Cinzel', serif;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%);
        }

        /* Elementos de Fundo (Parallax simulado) */
        .bg-element {
            position: absolute;
            font-size: 100px;
            opacity: 0.3;
            pointer-events: none;
        }

        canvas {
            display: block;
        }

        /* Interface */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #2c0e37;
            font-weight: bold;
            text-shadow: 2px 2px 0px #fff;
            pointer-events: none;
            z-index: 10;
        }

        /* Controlos M√≥veis */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 120px;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* Deixa passar toques onde n√£o h√° bot√µes */
            z-index: 20;
        }
       
        /* Esconde controlos em PC se n√£o for touch (opcional, mas bom ter sempre vis√≠vel para teste) */
        @media (min-width: 1024px) {
            #mobile-controls { display: none; }
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid #2c0e37;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            pointer-events: auto; /* Reativa toques nos bot√µes */
            color: #2c0e37;
        }

        .control-group {
            display: flex;
            gap: 20px;
        }

        /* Telas de Menu */
        #menu-screen, #game-over-screen, #win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 14, 55, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 30;
            text-align: center;
        }

        h1 { margin: 0; font-size: 3em; color: #FFD700; text-shadow: 0 0 10px #FFD700; }
        p { font-size: 1.5em; margin: 10px 0 30px 0; }
       
        .btn {
            padding: 15px 40px;
            font-size: 1.5em;
            background: #FF0066;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            box-shadow: 0 5px 0 #990033;
            transition: transform 0.1s;
        }
        .btn:active { transform: translateY(5px); box-shadow: none; }
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <!-- Decora√ß√£o de fundo -->
    <div class="bg-element" style="top: 10%; left: 10%;">üçÑ</div>
    <div class="bg-element" style="top: 20%; left: 80%;">üå≤</div>
    <div class="bg-element" style="top: 60%; left: 40%;">üè∞</div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        Pontos: <span id="score">0</span>
    </div>

    <div id="mobile-controls">
        <div class="control-group">
            <div class="control-btn" id="btn-left">‚¨ÖÔ∏è</div>
            <div class="control-btn" id="btn-right">‚û°Ô∏è</div>
        </div>
        <div class="control-btn" id="btn-jump">‚¨ÜÔ∏è</div>
    </div>

    <!-- Menus -->
    <div id="menu-screen">
        <h1>Alice: A Aventura</h1>
        <p>Corre, salta e chega ao castelo!</p>
        <button class="btn" onclick="startGame()">Jogar</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>Oh n√£o!</h1>
        <p>Apanharam-te!</p>
        <button class="btn" onclick="startGame()">Tentar de Novo</button>
    </div>

    <div id="win-screen" class="hidden">
        <h1>Vit√≥ria!</h1>
        <p>Chegaste a tempo para o ch√°!</p>
        <button class="btn" onclick="startGame()">Jogar Outra Vez</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
   
    // Estado do Jogo
    let gameState = 'menu'; // menu, playing, gameover, win
    let animationId;
    let score = 0;

    // Dimens√µes
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Inputs
    const keys = {
        left: false,
        right: false,
        up: false
    };

    // F√≠sica
    const GRAVITY = 0.8;
    const FRICTION = 0.8;
    const JUMP_FORCE = -15;
    const SPEED = 5;

    // C√¢mara
    let camera = { x: 0, y: 0 };

    // Alice
    const alice = {
        x: 100,
        y: 100,
        w: 40,
        h: 60,
        vx: 0,
        vy: 0,
        grounded: false,
        sprite: 'üë©üèº',
        facingRight: true
    };

    // N√≠vel (Plataformas, Inimigos, Itens)
    let platforms = [];
    let enemies = [];
    let items = [];
    let clouds = [];
    let finishLine = 0;

    // Gerador de N√≠veis
    function generateLevel() {
        platforms = [];
        enemies = [];
        items = [];
        clouds = [];
        score = 0;
        document.getElementById('score').innerText = '0';

        let currentX = 0;
        const groundY = canvas.height - 50;

        // Ch√£o inicial
        platforms.push({ x: -100, y: groundY, w: 600, h: 50, type: 'grass' });
        currentX = 500;

        // Gerar percurso
        for (let i = 0; i < 20; i++) {
            // Criar buraco ou plataforma
            const gap = 100 + Math.random() * 100;
            const width = 200 + Math.random() * 300;
            const heightChange = (Math.random() - 0.5) * 200;
            let newY = groundY + heightChange;
           
            // Limitar altura para n√£o ficar imposs√≠vel
            if (newY < 200) newY = 200;
            if (newY > canvas.height - 50) newY = canvas.height - 50;

            platforms.push({ x: currentX + gap, y: newY, w: width, h: 50, type: 'grass' });
           
            // Adicionar Inimigos (Cartas)
            if (Math.random() > 0.4) {
                enemies.push({
                    x: currentX + gap + 50,
                    y: newY - 50,
                    w: 40,
                    h: 50,
                    vx: 2,
                    minX: currentX + gap,
                    maxX: currentX + gap + width - 40,
                    sprite: 'üÉè'
                });
            }

            // Adicionar Itens (Bolos)
            if (Math.random() > 0.3) {
                items.push({
                    x: currentX + gap + width/2,
                    y: newY - 80,
                    w: 30,
                    h: 30,
                    sprite: 'üßÅ',
                    floatingY: 0
                });
            }

            // Plataformas flutuantes extra
            if (Math.random() > 0.5) {
                 platforms.push({
                     x: currentX + gap + 50,
                     y: newY - 150,
                     w: 100,
                     h: 20,
                     type: 'cloud'
                });
            }

            currentX += gap + width;
        }

        // Porta final
        finishLine = currentX;
        platforms.push({ x: finishLine, y: groundY, w: 500, h: 50, type: 'grass' });
       
        // Nuvens de fundo
        for(let i=0; i<30; i++) {
            clouds.push({
                x: Math.random() * finishLine,
                y: Math.random() * (canvas.height/2),
                speed: 0.2 + Math.random() * 0.5
            });
        }
       
        // Reset Alice
        alice.x = 100;
        alice.y = groundY - 100;
        alice.vx = 0;
        alice.vy = 0;
        camera.x = 0;
    }

    // Input Handlers
    window.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') keys.left = true;
        if (e.key === 'ArrowRight') keys.right = true;
        if ((e.key === 'ArrowUp' || e.key === ' ') && alice.grounded) {
            alice.vy = JUMP_FORCE;
            alice.grounded = false;
        }
    });

    window.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'ArrowRight') keys.right = false;
    });

    // Touch Controls
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnJump = document.getElementById('btn-jump');

    const addTouch = (elem, code) => {
        elem.addEventListener('touchstart', (e) => { e.preventDefault(); if(code === 'jump' && alice.grounded) { alice.vy = JUMP_FORCE; alice.grounded = false; } else keys[code] = true; });
        elem.addEventListener('touchend', (e) => { e.preventDefault(); if(code !== 'jump') keys[code] = false; });
    };

    addTouch(btnLeft, 'left');
    addTouch(btnRight, 'right');
    addTouch(btnJump, 'jump');

    // L√≥gica Principal
    function update() {
        if (gameState !== 'playing') return;

        // Movimento Horizontal
        if (keys.left) {
            alice.vx = -SPEED;
            alice.facingRight = false;
        } else if (keys.right) {
            alice.vx = SPEED;
            alice.facingRight = true;
        } else {
            alice.vx *= FRICTION;
        }

        alice.x += alice.vx;

        // Gravidade
        alice.vy += GRAVITY;
        alice.y += alice.vy;

        // Colis√£o com Plataformas
        alice.grounded = false;
        for (let p of platforms) {
            // Verifica se est√° acima da plataforma e a cair
            if (alice.x + alice.w > p.x &&
                alice.x < p.x + p.w &&
                alice.y + alice.h >= p.y &&
                alice.y + alice.h <= p.y + alice.vy + 20 && // Toler√¢ncia
                alice.vy >= 0) {
               
                alice.grounded = true;
                alice.vy = 0;
                alice.y = p.y - alice.h;
            }
        }

        // Colis√£o com Inimigos
        for (let e of enemies) {
            // Movimento do inimigo (Patrulha)
            e.x += e.vx;
            if (e.x < e.minX || e.x > e.maxX) e.vx *= -1;

            // Hitbox simples
            if (alice.x < e.x + e.w &&
                alice.x + alice.w > e.x &&
                alice.y < e.y + e.h &&
                alice.y + alice.h > e.y) {
               
                // Morte
                if (alice.y + alice.h - 10 < e.y) {
                    // Mario stomp (opcional, aqui vamos s√≥ fazer game over por simplicidade ou reiniciar)
                    // Vamos fazer game over
                    gameState = 'gameover';
                    document.getElementById('game-over-screen').classList.remove('hidden');
                } else {
                    gameState = 'gameover';
                    document.getElementById('game-over-screen').classList.remove('hidden');
                }
            }
        }

        // Colis√£o com Itens
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            item.floatingY = Math.sin(Date.now() / 200) * 5; // Anima√ß√£o de flutuar
           
            if (alice.x < item.x + item.w &&
                alice.x + alice.w > item.x &&
                alice.y < item.y + item.h &&
                alice.y + alice.h > item.y) {
               
                items.splice(i, 1);
                score += 100;
                document.getElementById('score').innerText = score;
            }
        }

        // Morte por queda (Buraco)
        if (alice.y > canvas.height) {
            gameState = 'gameover';
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        // Vit√≥ria
        if (alice.x > finishLine + 100) {
            gameState = 'win';
            document.getElementById('win-screen').classList.remove('hidden');
        }

        // C√¢mara segue a Alice (suave)
        let targetCamX = alice.x - canvas.width / 3;
        // Limites da c√¢mara
        if (targetCamX < 0) targetCamX = 0;
        if (targetCamX > finishLine - canvas.width + 500) targetCamX = finishLine - canvas.width + 500;
       
        camera.x += (targetCamX - camera.x) * 0.1;
    }

    function draw() {
        // Limpar ecr√£
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-camera.x, 0);

        // Nuvens (Parallax ligeiro)
        for (let c of clouds) {
            ctx.font = '60px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.fillText('‚òÅÔ∏è', c.x + camera.x * 0.5, c.y); // Movem-se com a c√¢mara mas mais devagar
        }

        // Plataformas
        for (let p of platforms) {
            if (p.type === 'grass') {
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(p.x, p.y, p.w, p.h);
                // Borda de relva
                ctx.fillStyle = '#388E3C';
                ctx.fillRect(p.x, p.y, p.w, 10);
            } else {
                ctx.fillStyle = '#FFF';
                ctx.fillRect(p.x, p.y, p.w, p.h);
            }
        }

        // Porta Final
        ctx.font = '80px Arial';
        ctx.fillText('üö™', finishLine + 200, canvas.height - 100);
        ctx.font = '20px Cinzel';
        ctx.fillStyle = '#333';
        ctx.fillText('CASTELO', finishLine + 210, canvas.height - 120);

        // Itens
        for (let item of items) {
            ctx.font = '30px Arial';
            ctx.fillText(item.sprite, item.x, item.y + item.floatingY);
        }

        // Inimigos
        for (let e of enemies) {
            ctx.save();
            ctx.translate(e.x + e.w/2, e.y + e.h/2);
            if (e.vx > 0) ctx.scale(-1, 1); // Virar sprite
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(e.sprite, 0, 0);
            ctx.restore();
        }

        // Alice
        ctx.save();
        ctx.translate(alice.x + alice.w/2, alice.y + alice.h/2);
        if (!alice.facingRight) ctx.scale(-1, 1);
        ctx.font = '50px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(alice.sprite, 0, 0);
        ctx.restore();

        ctx.restore();
    }

    function loop() {
        update();
        draw();
        animationId = requestAnimationFrame(loop);
    }

    function startGame() {
        document.getElementById('menu-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('win-screen').classList.add('hidden');
       
        generateLevel();
        gameState = 'playing';
       
        if (animationId) cancelAnimationFrame(animationId);
        loop();
    }

    // Iniciar loop visual (menu)
    loop();

</script>
</body>
</html>
