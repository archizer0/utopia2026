<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Alice Panda Kart: Chase Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
        }

        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            border: 3px solid #ff69b4;
            backdrop-filter: blur(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transform: skewX(-10deg);
        }

        .hud-text { font-size: 28px; font-weight: bold; color: white; text-shadow: 2px 2px 0 #ff00cc; transform: skewX(10deg); }
        .sub-text { font-size: 14px; color: #ddd; transform: skewX(10deg); text-transform: uppercase; letter-spacing: 1px; }

        /* Espelho Retrovisor (Novo) */
        #rear-view {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 60px;
            background: #333;
            border: 4px solid #fff;
            border-radius: 10px;
            z-index: 12;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        #rear-view-label {
            position: absolute;
            top: 2px;
            font-size: 10px;
            color: #aaa;
            z-index: 2;
        }
        #rear-queen-icon {
            font-size: 40px;
            transition: transform 0.2s;
        }

        /* Boost Bar */
        #boost-wrapper {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            text-align: center;
        }
        #boost-container {
            width: 100%;
            height: 25px;
            background: rgba(0,0,0,0.6);
            border-radius: 15px;
            border: 3px solid white;
            overflow: hidden;
            position: relative;
        }
        #boost-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff00cc, #ffff00, #ff00cc);
            background-size: 200% 100%;
            animation: gradientMove 2s linear infinite;
            transition: width 0.2s;
        }
        @keyframes gradientMove { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }
        
        #boost-msg {
            font-size: 20px;
            font-weight: bold;
            color: yellow;
            text-shadow: 0 0 5px red;
            margin-bottom: 5px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Screens */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(135, 206, 235, 0.95), rgba(255, 105, 180, 0.95));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
        }

        h1 {
            font-size: 3.5rem;
            color: #fff;
            text-shadow: 4px 4px 0px #ff00cc;
            margin-bottom: 10px;
            font-family: 'Impact', sans-serif;
            letter-spacing: 2px;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.05); } }

        button {
            margin-top: 30px;
            padding: 15px 60px;
            font-size: 2rem;
            background: #ff00cc;
            color: white;
            border: 4px solid white;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 0 #99007a;
            transition: all 0.1s;
            font-family: 'Comic Sans MS', sans-serif;
            font-weight: bold;
        }
        button:active { transform: translateY(5px); box-shadow: 0 5px 0 #99007a; }

        .hidden { display: none !important; }

        /* Danger Overlay */
        #danger-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 50px 20px red;
            pointer-events: none;
            opacity: 0;
            z-index: 5;
            transition: opacity 0.5s;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%; 
            display: none;
            z-index: 15;
        }
        
        .touch-zone {
            position: absolute;
            height: 100%;
            width: 50%;
            top: 0;
        }
        #zone-left { left: 0; }
        #zone-right { right: 0; }

        .touch-btn {
            position: absolute;
            bottom: 30px;
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border: 4px solid white;
            pointer-events: none; 
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            backdrop-filter: blur(4px);
        }
        #visual-left { left: 30px; }
        #visual-right { right: 30px; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="danger-overlay"></div>

        <!-- HUD -->
        <div id="hud">
            <div class="hud-panel">
                <div id="score-display" class="hud-text">0</div>
                <div class="sub-text">PONTOS</div>
            </div>
            <div class="hud-panel" style="text-align: right;">
                <div id="danger-display" class="hud-text" style="color: #00ff00;">SEGURO</div>
                <div class="sub-text">DIST√ÇNCIA</div>
            </div>
        </div>

        <!-- Retrovisor -->
        <div id="rear-view">
            <div id="rear-view-label">RETROVISOR</div>
            <div id="rear-queen-icon">üëë</div>
        </div>

        <div id="boost-wrapper">
            <div id="boost-msg">HYPER MODE!</div>
            <div id="boost-container">
                <div id="boost-fill"></div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen">
            <h1>ALICE PANDA KART</h1>
            <p style="font-size: 1.5rem; color: #fff; text-shadow: 1px 1px 2px #000;">üèéÔ∏è Foge da Rainha!</p>
            <p style="color: #eee; font-weight: bold;">Ela vem de tr√°s! Olha pelo retrovisor.</p>
            <p style="font-size: 1rem; margin-top: 10px;">Use as Setas ou Toque para mudar de faixa</p>
            <button id="start-btn">FUGIR!</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden">
            <h1>APANHADA!</h1>
            <p style="font-size: 2rem; color: #fff;">Pontua√ß√£o Final: <span id="final-score">0</span></p>
            <button id="restart-btn">TENTAR DE NOVO</button>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div id="zone-left" class="touch-zone"></div>
            <div id="zone-right" class="touch-zone"></div>
            <div id="visual-left" class="touch-btn">‚óÄ</div>
            <div id="visual-right" class="touch-btn">‚ñ∂</div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Configura√ß√£o ---
        const Config = {
            laneWidth: 6,
            laneCount: 5, 
            roadWidth: 40,
            speedMin: 0.8,
            speedMax: 2.5,
            hyperSpeed: 4.5,
            spawnRate: 15,
            queenCatchDistance: 20
        };

        let scene, camera, renderer;
        let player, queen, road;
        let obstacles = [];
        let scenery = [];
        let particles = [];
        
        // Estado
        const state = {
            isPlaying: false,
            score: 0,
            speed: 0,
            currentLane: 0, 
            targetX: 0,
            playerX: 0,
            boost: 0,
            isHyper: false,
            hyperTimer: 0,
            queenDist: 100, 
            shakeIntensity: 0
        };

        // Assets
        const Mats = {};

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.02);

            // C√¢mara ajustada para ver "atr√°s" (mais alta e recuada)
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 14); // Mais alta (8) e mais atr√°s (14)
            camera.lookAt(0, 0, -5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Luzes
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffd700, 0.9);
            sun.position.set(30, 50, 20);
            sun.castShadow = true;
            scene.add(sun);

            createMaterials();
            createWorld();
            player = createPlayer();
            scene.add(player);
            queen = createQueen();
            scene.add(queen);

            // Listeners
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', handleKey);

            if('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.getElementById('mobile-controls').style.display = 'block';
                document.getElementById('zone-left').addEventListener('touchstart', (e) => { e.preventDefault(); changeLane(-1); pulseBtn('visual-left'); });
                document.getElementById('zone-right').addEventListener('touchstart', (e) => { e.preventDefault(); changeLane(1); pulseBtn('visual-right'); });
            }

            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', startGame);

            animate();
        }

        function pulseBtn(id) {
            const btn = document.getElementById(id);
            btn.style.transform = "scale(0.9)";
            setTimeout(() => { btn.style.transform = "scale(1)"; }, 100);
        }

        function createMaterials() {
            // Textura da Estrada
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#555'; ctx.fillRect(0,0,256,256);
            ctx.fillStyle = '#fff';
            const lanePx = 256 / 5;
            for(let i=1; i<5; i++) {
                ctx.fillRect(i*lanePx - 2, 0, 4, 100); 
                ctx.fillRect(i*lanePx - 2, 128, 4, 100);
            }
            const roadTex = new THREE.CanvasTexture(canvas);
            roadTex.wrapS = THREE.RepeatWrapping; roadTex.wrapT = THREE.RepeatWrapping;
            roadTex.repeat.set(1, 10);
            Mats.road = new THREE.MeshStandardMaterial({ map: roadTex, roughness: 0.8 });
            
            // Relva
            const c = document.createElement('canvas'); c.width=128; c.height=128;
            const ctx2 = c.getContext('2d');
            ctx2.fillStyle = '#66cc66'; ctx2.fillRect(0,0,128,128);
            ctx2.fillStyle = '#55bb55'; ctx2.fillRect(0,0,64,64); ctx2.fillRect(64,64,64,64);
            const grassTex = new THREE.CanvasTexture(c);
            grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping; grassTex.repeat.set(50, 50);
            Mats.grass = new THREE.MeshStandardMaterial({ map: grassTex });

            Mats.white = new THREE.MeshStandardMaterial({ color: 0xffffff });
            Mats.black = new THREE.MeshStandardMaterial({ color: 0x111111 });
            Mats.red = new THREE.MeshStandardMaterial({ color: 0xff3333 });
            Mats.gold = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.6, roughness: 0.2 });
            Mats.hyper = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            Mats.blueCar = new THREE.MeshStandardMaterial({ color: 0x00BFFF });
        }

        function createWorld() {
            const roadGeo = new THREE.PlaneGeometry(Config.laneWidth * Config.laneCount, 2000);
            road = new THREE.Mesh(roadGeo, Mats.road);
            road.rotation.x = -Math.PI / 2;
            road.receiveShadow = true;
            scene.add(road);

            const floorGeo = new THREE.PlaneGeometry(500, 2000);
            const floor = new THREE.Mesh(floorGeo, Mats.grass);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.1;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        function createPlayer() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.0, 1.5, 16), Mats.blueCar);
            body.rotation.x = Math.PI/2;
            body.position.y = 1.0;
            body.castShadow = true;
            group.add(body);

            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12);
            [[1.2,1], [-1.2,1], [1.2,-1], [-1.2,-1]].forEach(p => {
                const w = new THREE.Mesh(wheelGeo, Mats.black);
                w.rotation.z = Math.PI/2;
                w.position.set(p[0], 0.5, p[1]);
                group.add(w);
            });

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.7), Mats.white);
            head.position.y = 1.8;
            group.add(head);
            const ear = new THREE.Mesh(new THREE.SphereGeometry(0.25), Mats.black);
            const e1 = ear.clone(); e1.position.set(-0.6, 2.4, 0); group.add(e1);
            const e2 = ear.clone(); e2.position.set(0.6, 2.4, 0); group.add(e2);
            const bow = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.3, 0.1), new THREE.MeshBasicMaterial({color: 0xff69b4}));
            bow.position.set(0, 2.5, 0.5);
            group.add(bow);
            return group;
        }

        function createQueen() {
            const group = new THREE.Group();
            
            // Corpo da Rainha (Carta Mais Pequena)
            const card = new THREE.Mesh(new THREE.BoxGeometry(6, 9, 1), Mats.white);
            card.position.y = 4;
            
            // Cora√ß√£o
            const heart = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 1), Mats.red);
            heart.position.set(0, 4, 0.6);
            
            // Coroa
            const crown = new THREE.Mesh(new THREE.ConeGeometry(1.5, 1.2, 8), Mats.gold);
            crown.position.set(0, 9, 0);

            group.add(card, heart, crown);
            return group;
        }

        function spawnObject() {
            if(Math.random() * 100 > Config.spawnRate) return;
            const isRabbit = Math.random() > 0.65;
            const group = new THREE.Group();
            
            if (isRabbit) {
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), Mats.white);
                body.position.y = 0.6;
                const ears = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 0.2), Mats.white);
                ears.position.set(0, 1.4, 0);
                group.add(body, ears);
                group.userData = { type: 'rabbit', val: 100 };
            } else {
                const card = new THREE.Mesh(new THREE.BoxGeometry(2.5, 3.5, 0.1), Mats.white);
                card.position.y = 1.75;
                const spot = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.2), Mats.red);
                spot.position.y = 1.75;
                group.add(card, spot);
                group.userData = { type: 'card', val: 10 };
            }

            const laneIndex = Math.floor(Math.random() * 5) - 2; 
            const x = laneIndex * Config.laneWidth;
            group.position.set(x, 0, -100); // Nasce longe √† frente (-Z)
            scene.add(group);
            obstacles.push(group);
        }

        function spawnScenery() {
            if(Math.random() * 100 > 10) return;
            const group = new THREE.Group();
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 2), Mats.white);
            stem.position.y = 1;
            const cap = new THREE.Mesh(new THREE.ConeGeometry(2, 1.5, 8), Mats.red);
            cap.position.y = 2;
            group.add(stem, cap);
            const side = Math.random() > 0.5 ? 1 : -1;
            const x = side * (Config.laneWidth * 3 + Math.random() * 20);
            group.position.set(x, 0, -100);
            scene.add(group);
            scenery.push(group);
        }

        function startGame() {
            state.isPlaying = true;
            state.score = 0;
            state.speed = Config.speedMin;
            state.queenDist = 100;
            state.boost = 0;
            state.isHyper = false;
            state.currentLane = 0;
            
            obstacles.forEach(o => scene.remove(o)); obstacles = [];
            scenery.forEach(s => scene.remove(s)); scenery = [];
            
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('danger-overlay').style.opacity = 0;
        }

        function handleKey(e) {
            if (!state.isPlaying) return;
            if(e.key === 'ArrowLeft' || e.key === 'a') changeLane(-1);
            if(e.key === 'ArrowRight' || e.key === 'd') changeLane(1);
        }

        function changeLane(dir) {
            state.currentLane += dir;
            if (state.currentLane < -2) state.currentLane = -2;
            if (state.currentLane > 2) state.currentLane = 2;
            state.targetX = state.currentLane * Config.laneWidth;
        }

        function update() {
            if(!state.isPlaying) return;

            // Movimento Jogador
            state.playerX += (state.targetX - state.playerX) * 0.15;
            const tilt = (state.targetX - state.playerX) * 0.05;
            player.rotation.z = tilt;
            player.rotation.y = tilt * 0.5;
            player.position.x = state.playerX;

            // Velocidade e Hyper
            if (state.isHyper) {
                state.speed = Config.hyperSpeed;
                state.hyperTimer--;
                state.queenDist += 0.5;
                player.children[0].material = Mats.hyper;
                if (state.hyperTimer <= 0) {
                    state.isHyper = false;
                    player.children[0].material = Mats.blueCar;
                    document.getElementById('boost-msg').style.opacity = 0;
                }
            } else {
                if(state.speed < Config.speedMax) state.speed += 0.0005;
            }

            // Spawns
            spawnObject();
            spawnScenery();
            
            const moveSpeed = state.speed;

            // Obst√°culos
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const o = obstacles[i];
                o.position.z += moveSpeed;
                
                if (Math.abs(o.position.z - player.position.z) < 2.5) {
                    if (Math.abs(o.position.x - player.position.x) < 2.0) {
                        if (o.userData.type === 'rabbit') {
                            state.score += 100;
                            state.boost += 20;
                            if (state.boost >= 100 && !state.isHyper) {
                                state.isHyper = true;
                                state.hyperTimer = 300;
                                state.boost = 0;
                                document.getElementById('boost-msg').style.opacity = 1;
                            }
                            state.queenDist += 2;
                        } else {
                            if (state.isHyper) {
                                state.score += 50;
                                createParticles(o.position.x, o.position.z, 0xaaaaaa);
                            } else {
                                state.score += 10;
                                state.speed = Config.speedMin;
                                state.queenDist -= 15; // Rainha aproxima-se muito
                                state.shakeIntensity = 20;
                                createParticles(o.position.x, o.position.z, 0xff0000);
                            }
                        }
                        scene.remove(o);
                        obstacles.splice(i, 1);
                        continue;
                    }
                }
                if (o.position.z > 20) { scene.remove(o); obstacles.splice(i, 1); }
            }
            scenery.forEach(s => { s.position.z += moveSpeed; });

            // --- L√≥gica da Rainha (CORRIGIDA) ---
            // A Rainha est√° ATR√ÅS do jogador (Z Positivo)
            // Distancia 100 (Seguro) -> Rainha longe atr√°s (Z=30)
            // Distancia 0 (Perigo) -> Rainha toca no jogador (Z=2)
            
            if (!state.isHyper && state.speed < 1.2) state.queenDist -= 0.15;
            else state.queenDist += 0.05;
            state.queenDist = Math.min(state.queenDist, 100);

            // Z varia de 3 (Perigo) a 25 (Longe/Atr√°s da c√¢mara)
            // Invertemos a l√≥gica: quanto menor a dist, menor o Z (mais perto do jogador em Z=0)
            const queenZ = 3 + (state.queenDist / 100 * 22); 
            
            queen.position.z += (queenZ - queen.position.z) * 0.1;
            queen.position.x += (state.playerX - queen.position.x) * 0.05; // Segue na horizontal

            // Retrovisor UI
            const mirrorIcon = document.getElementById('rear-queen-icon');
            // Quanto mais perto (dist menor), maior o icone
            const scale = 1 + ((100 - state.queenDist) / 100 * 2); // Escala de 1x a 3x
            mirrorIcon.style.transform = `scale(${scale})`;
            mirrorIcon.innerText = state.queenDist < 20 ? "üëø" : "üëë";

            if (state.queenDist <= 0) {
                state.isPlaying = false;
                document.getElementById('final-score').innerText = Math.floor(state.score);
                document.getElementById('game-over-screen').classList.remove('hidden');
            }

            // Shake e C√¢mara
            if (state.shakeIntensity > 0) {
                camera.position.x = (Math.random() - 0.5) * (state.shakeIntensity * 0.1);
                state.shakeIntensity--;
            } else {
                camera.position.x += (state.playerX * 0.3 - camera.position.x) * 0.1;
            }
            
            const targetFov = state.isHyper ? 85 : 70;
            camera.fov += (targetFov - camera.fov) * 0.05;
            camera.updateProjectionMatrix();

            Mats.road.map.offset.y -= state.speed * 0.02;

            updateParticles();
            updateUI();
        }

        function createParticles(x, z, color) {
            for(let i=0; i<10; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color: color}));
                p.position.set(x, 1, z);
                p.userData = { vel: new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)) };
                scene.add(p);
                particles.push(p);
            }
        }

        function updateParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.05; 
                p.rotation.x += 0.1;
                if(p.position.y < 0) { scene.remove(p); particles.splice(i,1); }
            }
        }

        function updateUI() {
            document.getElementById('score-display').innerText = Math.floor(state.score);
            document.getElementById('boost-fill').style.width = state.isHyper ? '100%' : state.boost + '%';
            
            const dangerDiv = document.getElementById('danger-display');
            const overlay = document.getElementById('danger-overlay');
            
            if (state.queenDist < 25) {
                dangerDiv.innerText = "FOGE!!";
                dangerDiv.style.color = "red";
                dangerDiv.style.fontSize = "32px";
                // Ecr√£ vermelho
                overlay.style.opacity = (25 - state.queenDist) / 25;
            } else {
                dangerDiv.innerText = Math.floor(state.queenDist) + "m";
                dangerDiv.style.color = "#00ff00";
                dangerDiv.style.fontSize = "28px";
                overlay.style.opacity = 0;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>